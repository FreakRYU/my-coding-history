# 전체탐색 - 테이블 문제

전체사람수 = int(input("전체사람수를 입력해주세요 > "))
앉을수있는최대인원 = int(input("앉을 수 있는 최대인원을 입력해주세요 > "))
앉을수있는최소인원 = int(input("앉을 수 있는 최소인원을 입력해주세요 > "))

memo = {}
# 남은사람수와 앉힌사람수를 입력하는 순간 memo에 저장될 키로 정의된다.(아직 저장된 것은 아니다.)
def graph(남은사람수, 앉힌사람수):
    key = (남은사람수, 앉힌사람수)

    if key in memo:
        return memo[key]

    if 남은사람수 < 0:
        return 0

    if 남은사람수 == 0:
        return 1

    count = 0
    for i in range(max(앉을수있는최소인원, 앉힌사람수), min(남은사람수, 앉을수있는최대인원)+1):
        count += graph(남은사람수 - i, i)

    memo[key] = count
    # 이미 메모에 있는 값이라면, 그 값을 총 경우의 수에 더해질 것이고, 처음 계산되는 것이라면 1이 더해질 것이다.

    # 다시 앉혀야될 사람의 수는 이전에 앉힌사람수보다 작게되면, 경우가 겹치게 된다.
    # 예를 들어, 총 6명에서 4명 앉히고 2명이 남게 되고, 여기서 2명부터 시작하여 앉히게 되면,
    # 총 6명에서 2명 앉히고 4명이 남은 경우와 같게 된다. 이유는 앉히는 순서는 존재하지 않고 앉히는 방법만 존재하기 때문이다.
    # 더 구체적으로 앉히는 사람의 수의 변화 양상이 모든 경우를 세는 데 있어 통일성이 있어야한다.
    # 만약 앉히는 사람수의 변화가 증가하는 경우와 감소하는 경우는 앉히는 방법이 중복되기 때문이다.
    # 가령 9명에서 2명 앉히고 3명 앉히고 4명 앉히는 경우의 수와
    # 9명에서 4명 앉히고 3명 앉히고 2명 앉히는 경우의 수가 같기 때문이다.
    return count

    
print(graph(전체사람수, 0))    